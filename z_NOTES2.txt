--------------------------------------------------------
let obj = {
	name: 'wee',
  age: 5,
};

let arr = ['a', 'b', 'c', 'd', 'e'];

for (let key of obj) {
  console.log(key);   --> Error, obj not iterable
}
for (let key in obj) {
  console.log(key);   --> "name", "age"
}

for (let key of arr) {
	console.log(key);   --> "a", "b", "c", "d", "e"
}
for (let key in arr) {
  console.log(key);   --> "0", "1", "2", "3", "4"
}
--------------------------------------------------------#
- for ... in vs. for ... of 
https://stackoverflow.com/questions/29285897/what-is-the-difference-between-for-in-and-for-of-statements
- for ... in --> loops over enumerable property names of an object
  - property names of arrays is the ** index ** then I think 
- for ... of --> does use an object-specific iterator and loops over the values generated by that
  - for of is useful for array iteration 
  
--------------------------------------------------------
const persons = [
  { name: 'John Smith' },
  { name: 'Jane Doe' }
];

for (const { name } of persons) {
  console.log(name);
}
--------------------------------------------------------#
- for ... of --> useful for in-place destructuring *** 
https://dmitripavlutin.com/javascript-for-of/


--------------------------------------------------------
const object1 = {
  a: 'somestring',
  b: 42
};

for (const [key, value] of Object.entries(object1)) {
	console.log(`${key}: ${value}`);
}
--------------------------------------------------------#
- Object.entries(...) 


https://dmitripavlutin.com/how-to-compare-objects-in-javascript/
- Referencial Equality
- Shallow/Deep Equality of js objects 



https://stackoverflow.com/questions/22644328/when-is-the-thread-pool-used
- js <<Thread Pool>> (super in-depth) *************

- Q: are eventlistener callbacks asynchronous? 
https://softwareengineering.stackexchange.com/questions/194580/how-does-javascript-code-become-asynchronous-when-using-callbacks/194591
- see the last answer 


--------------------------------------------------------
async function sth() {
	let message = "result";
  console.log(message);
}
async function sth2() {
  let message = await "result";
  console.log(message);
}

sth();
console.log('flag1');
<result>:
'result' --> 'flag1'

sth2();
console.log('flag2');
<result>:
'flag2' --> 'result'
--------------------------------------------------------#
- await applies to non-Promises as well (didn't know)
- sth() runs asynchronously only when await is used (ith) 


https://medium.com/swlh/asynchronous-javascript-in-depth-1e66c65f96fe
- call stack, message queue, job queue 
- maybe callback queue consists of message queue & job queue ?
- message queue vs. job queue
  - They are different and have different priority. Job queue is introduced
    in ES6 because of Promises. So the callbacks for promises are added into
    Job queue and all other callbacks are added in Message/Event queue.
https://medium.com/@Rahulx1/understanding-event-loop-call-stack-event-job-queue-in-javascript-63dcd2c71ecd
- <<GREAT MEDIUM ARTICLE on job queue & callback queue>>
  - job queue takes priority over callback queue 
- I think callback queue === message queue === event queue *** 
  - and then there's a separate job queue 

https://stackoverflow.com/questions/37419572/if-async-await-doesnt-create-any-additional-threads-then-how-does-it-make-appl
- <<GREAT STACKOVERFLOW POST on async/await & how it works under the hood >>
<<summary>>:
- when await encountered, the async func is stopped while event loop keeps running
- when Promise resolves, the then callback gets queued up in job queue (waiting to be executed after exhaustion of call stack)
  - but when using await, there's no "then" callback --> the previously paused async code block
    resumes (the code after await) 
--------------------------------------------------------
let myPromise = new Promise((resolve, reject) => {
	console.log('flag1');
  setTimeout(() => {
		console.log('flag2');
  }, 1000);
  console.log('flag3');
  resolve('promise result');
});

console.log('start');
myPromise.then((x) => console.log(x));
myPromise.then((x) => console.log(x));
console.log('end');

<result>:
flag1 --> flag3 --> start --> end --> promise result --> promise result --> flag2         ****** EXTREMELY IMPORTANT 
--------------------------------------------------------#
- flag1 & flag3 & flag2 (setTimeout) gets run when the Promise is created, not every time it's run
  - WHY ??? (see the following example:)
  
--------------------------------------------------------
function makePromise(partyPromise) {
   return new Promise(function (resolve, reject) {
   		console.log('asdf');
      setTimeout(() => {
          console.log("timeout!");
      }, 1000);
      resolve('promise done');
  });
}

makePromise().then(x => console.log(x))
<result>:
asdf --> promise done --> timeout!

makePromise().then(x => console.log(x))
makePromise().then(x => console.log(x))
<result>:
asdf --> asdf --> promise done --> promise done --> timeout! --> timeout!
--------------------------------------------------------#
- this time, since you create and return Promise on function call, console.log() gets run every func call

<<summary>>:
- then --> chaining then and doing everything inside the callbacks (usually don't assign values to left var)
- await --> avoiding chaining and assigning values to the left 



https://stackoverflow.com/questions/26167178/abstraction-in-oops/49979512
- What is Abstraction in OOP? 
- "Abstraction is a process where you show only “relevant” data and “hide”
  unnecessary details of an object from the user."
- For example, when you login to your Amazon account online, you enter your
  user_id and password and press login, what happens when you press login,
  how the input data sent to amazon server, how it gets verified is all abstracted away from the user


- GraphQL is a query langauge for APIS 
  - https://www.prisma.io/blog/graphql-server-basics-the-schema-ac5e2950214e
  - GraphQL article (official prisma site) 
- REST is a software architectural style to which APIs conform so devs can interact with
  services in a standard way 
https://www.howtographql.com/
- graphql tutorials (graphql-node, react-apollo)
https://medium.com/techtalkers/a-beginners-guide-to-graphql-12d60d3fba03
- good beginner's tutorial 

JAM Stack: 
- Javascript, API, Markup 
- pre-rendered static pages served from CDN 
traditional monolithic architecture: 
- server up and running, at every request server works on generating dynamic html without cache 
JAM stack is an architecture
- while the MERN stack are specific technologies: MongoDB, Express, React, Node.js 

Full Stack Article (from official prisma website)
-  https://www.prisma.io/blog/fullstack-nextjs-graphql-prisma-oklidw1rhw
- TypeScript, PostgreSQL, Next.js, Prisma, GraphQL
- full stack app series (not completed yet) 


SWR 
- https://www.smashingmagazine.com/2020/06/introduction-swr-react-hooks-remote-data-fetching/
  - <<<what is SWR & why use it (and SWR example project --> Pokemon)>>>
- Axios or Fetch will just handle the request and return the expected response, nothing more.
- SWR has some nice features: caching, pagination, scroll position recovery, dependent fetching, etc.
- SWR under the hood uses the Fetch API to request data from the server
- SWRConfig Wrapper Cmp to use global configuration and the fetcher function 
- Features of SWR: 
  1. Focus Revalidation 
  2. Fetch on Interval 
  3. Local Mutation
  4. Scroll Position Recovery 
  5. Dependent Fetching
  
https://swr.vercel.app/docs/prefetching
- prefetch (I know, the same concept from next.js, but it's DIFFERENT)
  - SWR's prefetch is for the DATA, while next.js's prefetch is for the page
  
https://react.christmas/2020/4
- SWR functionalities 

https://swr.vercel.app/docs/with-nextjs
- Client Side Data Fetching using SWR 
- Pre-rendering using SWR 
-------------------------------------------------------------------
export async function getStaticProps() {
  // `getStaticProps` is invoked on the server-side,
  // so this `fetcher` function will be executed on the server-side.
  const posts = await fetcher('https://jsonplaceholder.typicode.com/posts')
  return { props: { posts } }
}

function Posts (props) {
  // Here the `fetcher` function will be executed on the client-side.
  const { data } = useSWR('/api/posts', fetcher, { initialData: props.posts })

  // ...
}
-------------------------------------------------------------------#
- "The page is still pre-rendered"
- "But after hydration, it’s also fully powered by SWR in the client side.
  Which means the data can be dynamic and update itself over time and user interactions."
  

https://swr.vercel.app/docs/getting-started  **********
- UseEffect and passing prop (user) down to children 
- using useSWR, don't need useEffect in parent cmpt 

SWR is deduped (deduplicated, as long as multiple requests occur within a set time interval)
- which means only 1 request is made --> even though useSWR() is called multiple times 
- which lets you call useSWR (or custom hook that uses useSWR) inside each child cmpt 
  - this makes the children cmpt independent of the parent 
  - code is simpler 


https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters
- Rest Parameters 
-------------------------------------------------------------------
function sum(...theArgs) {
  return theArgs.reduce((previous, current) => {
    return previous + current;
  });
}
-------------------------------------------------------------------#



https://nextjs.org/docs/basic-features/pages#pre-rendering
- next.js pre-rendering explanation
"Next.js generates HTML for each page in advance, instead of having it all done by client-side JavaScript"
"Pre-rendering can result in better performance and SEO."
"Each generated HTML is associated with minimal JavaScript code necessary for that page. When a page
is loaded by the browser, its JavaScript code runs and makes the page fully interactive.
(This process is called hydration.)"
-------------------------------------------------------------------
(code from https://nextjs.org/docs/basic-features/data-fetching#fetching-data-on-the-client-side)
import useSWR from 'swr'

const fetcher = (url) => fetch(url).then((res) => res.json())

function Profile() {
  const { data, error } = useSWR('/api/user', fetcher)

  if (error) return <div>failed to load</div>
  if (!data) return <div>loading...</div>
  return <div>hello {data.name}!</div>
}
-------------------------------------------------------------------#
- useSWR hook inside cmpt 
<<inquiry>>:
- html is generated using minimal js code necessary for the page (--> static content cached in CDN)
- after hydration, js code runs to make page fully interactive 
  - here, does this mean the cmpt is being fully loaded? 
    - (Are parts of the code for the cmpt run (which is meant by minimal js), and then hydration occurs
      where the code for cmpt is fully run, including stuff like useState()?)




User Authentication 
https://leerob.io/blog/nextjs-authentication#firebase  (article)
https://www.youtube.com/watch?v=NSR_Y_rm_zU (video)
- SG
- SSR 
- Providers --> ex) Firebase Auth 
- Bring Your Own Database 
  - "If you have an existing database with user data, you'll likely want to utilize
    an open-source solution that's provider agnostic."
  - ex) next-iron-session, next-auth
    - If you need to persist session data on the server, use next-auth.
    - If you need to support social login (Google, Facebook, etc.), use next-auth.
    - If you want to use JWTs, use next-auth.



https://www.youtube.com/watch?v=OpoVuwxGRDI
- Cookies 
- cookie is info that gets stored in the browser (browser-specific then, ig)
- combination of Cookies & Sessions
- cookies don't contain sensitive information 
- sensitive, important info are stored on the session on the server 
- moving across different pages but remaining logged in indicates that cookies are used 
- for letting the user stay logged in involves:
  - cookie stores a key 
  - inside the http request, include the key in cookie 
  - server receives key and customizes response 
  - this is the use of cookie & session 

https://www.youtube.com/watch?v=bW31xiNB8Nc
- CORS --> cross-origin resource sharing 
- "...spring, django, express have in their docs how to include cors in the app"
- cors is like whitelisting the origins you want to allow request from 
  - by default, all origins are blocked 

https://www.youtube.com/watch?v=1QiOXWEbqYQ
- <<Session vs. JWT (json web token)>>
- a log in process (db stores hash value of user, while on the client side the user's
  credentials are used to compute a hash function --> then compares if the two values are the same) 
  is heavy, so doing this every request (upon page change) is cumbersome. 
  - bc of this, retaining user login state was traditionally done by Sessions. 
- Session
  - server generates session ticket, splits it, gives half to browser 
  - browser stores this as session id (cookie) 
  - upon every request in the website, browser sends this ticket, and server matches with the other half 
  - upon match, login state is preserved 
  - the other half (server's ticket) is saved in server's memory (out of memory, hard disk of server, db)
  BUT: 
  - too much session --> memory overload on server 
  - or if server reboot is necessary, the memory is reset (all users will get logged out)
    - could store ticket in hard disk of server, but fetching it on every request would be slower 
  - or if there are multiple servers --> if each request reaches a different server, user needs to log in
    again bc the user's ticket from the previous request doesn't match on a different server
    - this is a problem when using memory || hard disk to store server's ticket
    - could store ticket in shared db --> but would sacrifice speed by a great extent
  - As a solution (partial tho), JWT was invented
- JWT
  - gives a token to client, and forgets about it
  - XXX.YYY.ZZZ 
  - header.payload.verify-signature
  - payload --> all the info (expiration, level of access (admin stuff) )
    - encoded in base64
  - header --> type: JWT / alg: (type of algo to be used to render verify-signature using header, payload,
    and hidden key on the server side) (I think the key here is UNIQUE, only one  for the server)
      - (I think this hidden key is important --> bc server is not overloaded as it's a single val &
        it's consistent across mult- servers) *******
    - simplified: 2 + server-side-key --(using 1 algo)--> generates value, compares against 3
    - which makes it impossible to manipulate the payload info 
- Session is stateful, JWT is stateless
- JWT isn't perfect (bc it's stateless)
  - Session can do more things (log out user from certain device) 
  - JWT can't do that (bc can't take away the token it already gave and cannot track it either)
  - if JWT token is stolen by any chance, no way to stop it 
    - one workaround:
      - access token & refresh token 
      - access token expires quickly & refresh token requests new access token every time it expires,
        until the refresh token itself expires (access token: minutes, refresh token: abt 2 weeks)
        - refresh token's corresponding value is saved on server side as well 
        - client sends refresh token instead of access token if access token expires
        - received refresh token compared with the value on server db --> if a match, renew access token
        
        

SPA (single page application, apps made in plain React)
- Amazon Clone user Auth was simple: 
  - add auth listener (onAuthStateChange method from fireb)
  - change (using dispatch from useStateValue(), a custom hook) global user value 
  - in App.jsx, show login page if user is undefined or show app (wrapped in BrowserRouter, Switch, and Route) 
    if user exists 
- This above is critically different from next.js apps, I think, bc next.js apps are not SPA but multiple
  page application. SPA apps will be able to retain the user login info independent of page routing (bc 
  it's essentially inside a single page app with different routes/urls). However, next apps has multiple 
  pages, so the pages are actually separate, so there needs to be a way to check the user login state
(I think this is what it is) **********


plain react vs. next
- in plain react, the index.js contains app.js, where index.js renders the app in the "root" div
- in next, _app.js has the thing building pages with pageProps (not render at "root" div tho), while
  index.js is just the page for the '/' route



https://www.learnwithjason.dev/blog/wtf-is-jamstack
- what is JAM stack 
  - generating cacheable, static assets at build time whenever possible
  - deploying those assets to CDNs
  - using client-side JavaScript to call third-party APIs and serverless functions for
    dynamic interactions and data
https://adamchipperfield.com/server-side-rendering-is-not-part-of-the-jamstack/
- SSR is not part of JAM stack 
- So ig next.js can be used for JAM, but it's not limited to that (bc it also has SSR) 
- meaning JAM's focus doesn't include SEO? (next's SSR is also pre-rendered)
  (if pre-render, or SEO, was the foucs of JAM, they wouldn't say SSR isn't part of JAM, bc
  next's SSR is also pre-rendered)
  (JAM's primary focus is build-time static assets that are cacheable for CDN deployment)
  
https://blog.greenroots.info/jamstack-vs-traditional-monolithic-workflow
- <<JAMstack vs. traditional monolithic workflow>> *******  (part of JAMstack series)
  - good comparison between the two 
- CDN 
  - "There is not much advantage if a prebuilt markup when an origin server serves the content.
    It will be almost similar to the server-rendered applications."
  - I think the author meant to make a contrast in distance between server to client 
    - (and also the servers (edge nodes ig) rarely compute anything, I think) 
  https://vercel.com/docs/edge-network/overview
  - how CDN works (vercel doc) 

<<summary>>:
- traditional web architectures (monolithic) were implemented with server side rendering (SSR)
  - server compiled everything, included the data, and delievered a fully populated HTML page to client
  - slow (all that work on every request)
- SPA 
  - instead of server-side computation, does client-side computation 
  - SPA loads everything (all the pages at once) I think
    - which means all the css (and react) files need to be loaded together 
  - multi-page apps (next.js) load only the page requested (and prefetch <Link>s) I think 
    - only page-specific css modules are loaded (stated in next doc)
- JAM 
  - content is pre-built --> eliminates need for origin server 
  - can serve content from CDN 
  - this solves the problem (computing time) with SSR & SPA 
  - rollback (to previous deployments) is simpler 
  
  
  
- (I think revalidate === cache invalidation) 

<<realization>>:
- cms (headless, at least) takes advantage of reusability (bc you create content models) 


https://vercel.com/docs/edge-network/overview
- CDN (from vercel doc) 
- "The Vercel Edge Network sits in-between the internet and your Vercel deployments"
- https://www.youtube.com/watch?v=zE1S8CHkev8
  - @ 39:09 --> diagram of CDN of next.js app
  
  

----------------------------------------------------------
let obj = {
	fruit: ['a', 'b', 'c'],
  name: {
  	me: 'me'
  }
};

let { fruit: wow, name: { me: heon } } = obj;

console.log(wow);
wow.splice(0,1);
console.log('fruit: ', wow);
console.log('original fruit:', obj.fruit)
----------------------------------------------------------#
- nested destructuring (using alias ***)
- fruit: wow --> fruit as wow (alternate name)
- name: { me: heon } --> name as an alias in object form (so that you can specify values inside it)
  - me as heon here 



https://stackoverflow.com/questions/63612579/is-it-possible-to-directly-connect-frontend-to-the-database
- why you can't connect frontend directly to db (instead of backend interacting with db)
- security issues:
  - Your database is exposed, anyone can query the data from your db, just by running a db query in browser
    console, which exposes other users data too.


- api vs. db   for fetching data 
  - I think they are used in different situations

- how headless cms works (I think): 
  - contentful (headless cms) has api endpoint
  - hitting (calling) the api endpoint --> contentful's backend returns fetched data from db 
  - the hit was performed from gSProps (in the case of next apps) (gSProps is also backend code) 
    - (gSProps is backend code, hidden from client, so client can't manipulate api endpoint) 

<<summary>> (I think): 
- frontend (React Component prop) <--> backend (gSProps) <--> db 
- frontend (GrapQL query) <--> backend (serverless api) <--> db 
- is this correct? doesn't the second one's serverless api make it CSR? 
- when frontend tries to get data from db, it needs a backend (server or serverless) 
  so that it can make api calls to the backend where the backend will get the data for u 




